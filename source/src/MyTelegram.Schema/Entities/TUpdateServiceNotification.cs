// <auto-generated />

namespace MyTelegram.Schema;

/// <summary>
/// A service message for the user.The app must show the message to the user upon receiving this update. In case the <strong>popup</strong> parameter was passed, the text message must be displayed in a popup alert immediately upon receipt. It is recommended to handle the text as you would an ordinary message in terms of highlighting links, etc. The message must also be stored locally as part of the message history with the user id <code>777000</code> (Telegram Notifications).
/// <para>See <a href="https://corefork.telegram.org/constructor/updateServiceNotification" /></para>
/// </summary>
[TlObject(0xebe46819)]
public sealed partial class TUpdateServiceNotification : IUpdate
{
    public uint ConstructorId => 0xebe46819;
    /// <summary>
    /// Flags, see <a href="https://corefork.telegram.org/mtproto/TL-combinators#conditional-fields">TL conditional fields</a>
    /// </summary>
    public int Flags { get; set; }

    /// <summary>
    /// If set, the message must be displayed in a popup.
    /// </summary>
    public bool Popup { get; set; }

    /// <summary>
    /// If set, any eventual webpage preview will be shown on top of the message instead of at the bottom.
    /// </summary>
    public bool InvertMedia { get; set; }

    /// <summary>
    /// When was the notification received<br/>The message must also be stored locally as part of the message history with the user id <code>777000</code> (Telegram Notifications).
    /// </summary>
    public int? InboxDate { get; set; }

    /// <summary>
    /// String, identical in format and contents to the <a href="https://corefork.telegram.org/api/errors#error-type"><strong>type</strong></a> field in API errors. Describes type of service message. It is acceptable to ignore repeated messages of the same <strong>type</strong> within a short period of time (15 minutes).
    /// </summary>
    public string Type { get; set; }

    /// <summary>
    /// Message text
    /// </summary>
    public string Message { get; set; }

    /// <summary>
    /// Media content (optional)
    /// See <a href="https://corefork.telegram.org/type/MessageMedia" />
    /// </summary>
    public MyTelegram.Schema.IMessageMedia Media { get; set; }

    /// <summary>
    /// <a href="https://corefork.telegram.org/api/entities">Message entities for styled text</a>
    /// See <a href="https://corefork.telegram.org/type/MessageEntity" />
    /// </summary>
    public TVector<MyTelegram.Schema.IMessageEntity> Entities { get; set; }

    public void ComputeFlag()
    {
        if (Popup) { Flags = Flags.SetBit(0); }
        if (InvertMedia) { Flags = Flags.SetBit(2); }
        if (/*InboxDate != 0 && */InboxDate.HasValue) { Flags = Flags.SetBit(1); }
    }

    public void Serialize(IBufferWriter<byte> writer)
    {
        ComputeFlag();
        writer.Write(ConstructorId);
        writer.Write(Flags);
        if (Flags.IsBitSet(1)) { writer.Write(InboxDate.Value); }
        writer.Write(Type);
        writer.Write(Message);
        writer.Write(Media);
        writer.Write(Entities);
    }

    public void Deserialize(ref ReadOnlyMemory<byte> buffer)
    {
        Flags = buffer.ReadInt32();
        if (Flags.IsBitSet(0)) { Popup = true; }
        if (Flags.IsBitSet(2)) { InvertMedia = true; }
        if (Flags.IsBitSet(1)) { InboxDate = buffer.ReadInt32(); }
        Type = buffer.ReadString();
        Message = buffer.ReadString();
        Media = buffer.Read<MyTelegram.Schema.IMessageMedia>();
        Entities = buffer.Read<TVector<MyTelegram.Schema.IMessageEntity>>();
    }
}
