// <auto-generated />

namespace MyTelegram.Schema.Payments;

/// <summary>
/// Information about the value of a <a href="https://corefork.telegram.org/api/gifts#collectible-gifts">collectible gift »</a>.
/// <para>See <a href="https://corefork.telegram.org/constructor/payments.uniqueStarGiftValueInfo" /></para>
/// </summary>
[TlObject(0x512fe446)]
public sealed partial class TUniqueStarGiftValueInfo : IUniqueStarGiftValueInfo
{
    public uint ConstructorId => 0x512fe446;
    /// <summary>
    /// Flags, see <a href="https://corefork.telegram.org/mtproto/TL-combinators#conditional-fields">TL conditional fields</a>
    /// </summary>
    public int Flags { get; set; }

    /// <summary>
    /// If set, the last sale was completed on Fragment.
    /// </summary>
    public bool LastSaleOnFragment { get; set; }

    /// <summary>
    /// If set, the <code>value</code> is calculated from the average value of sold gifts of the same type. Otherwise, it is based on the sale price of the gift.
    /// </summary>
    public bool ValueIsAverage { get; set; }

    /// <summary>
    /// Three-letter ISO 4217 <a href="https://corefork.telegram.org/bots/payments#supported-currencies">currency</a> code (a localized fiat currency used to represent prices and price estimations in this constructor).
    /// </summary>
    public string Currency { get; set; }

    /// <summary>
    /// Estimated value of the gift, in the smallest unit of the currency specified in <code>currency</code>.
    /// </summary>
    public long Value { get; set; }

    /// <summary>
    /// Initial purchase date of the gift.
    /// </summary>
    public int InitialSaleDate { get; set; }

    /// <summary>
    /// Initial purchase price in Stars.
    /// </summary>
    public long InitialSaleStars { get; set; }

    /// <summary>
    /// Initial purchase price in the smallest unit of the currency specified in <code>currency</code> (automatically converted from <code>initial_sale_stars</code>).
    /// </summary>
    public long InitialSalePrice { get; set; }

    /// <summary>
    /// Last resale date of the gift.
    /// </summary>
    public int? LastSaleDate { get; set; }

    /// <summary>
    /// Last resale price, in the smallest unit of the currency specified in <code>currency</code>.
    /// </summary>
    public long? LastSalePrice { get; set; }

    /// <summary>
    /// The current minimum price of collectible gifts of the same type, in the smallest unit of the currency specified in <code>currency</code>.
    /// </summary>
    public long? FloorPrice { get; set; }

    /// <summary>
    /// The current average sale price of collectible gifts of the same type, in the smallest unit of the currency specified in <code>currency</code>.
    /// </summary>
    public long? AveragePrice { get; set; }

    /// <summary>
    /// Number of gifts of the same type currently being resold on Telegram.
    /// </summary>
    public int? ListedCount { get; set; }

    /// <summary>
    /// Number of gifts of the same type currently being resold on fragment.
    /// </summary>
    public int? FragmentListedCount { get; set; }

    /// <summary>
    /// Fragment link to the listing of gifts of the same type currently being resold on fragment.
    /// </summary>
    public string? FragmentListedUrl { get; set; }

    public void ComputeFlag()
    {
        if (LastSaleOnFragment) { Flags = Flags.SetBit(1); }
        if (ValueIsAverage) { Flags = Flags.SetBit(6); }
        if (/*LastSaleDate != 0 && */LastSaleDate.HasValue) { Flags = Flags.SetBit(0); }
        if (/*LastSalePrice != 0 &&*/ LastSalePrice.HasValue) { Flags = Flags.SetBit(0); }
        if (/*FloorPrice != 0 &&*/ FloorPrice.HasValue) { Flags = Flags.SetBit(2); }
        if (/*AveragePrice != 0 &&*/ AveragePrice.HasValue) { Flags = Flags.SetBit(3); }
        if (/*ListedCount != 0 && */ListedCount.HasValue) { Flags = Flags.SetBit(4); }
        if (/*FragmentListedCount != 0 && */FragmentListedCount.HasValue) { Flags = Flags.SetBit(5); }
        if (FragmentListedUrl != null) { Flags = Flags.SetBit(5); }
    }

    public void Serialize(IBufferWriter<byte> writer)
    {
        ComputeFlag();
        writer.Write(ConstructorId);
        writer.Write(Flags);
        writer.Write(Currency);
        writer.Write(Value);
        writer.Write(InitialSaleDate);
        writer.Write(InitialSaleStars);
        writer.Write(InitialSalePrice);
        if (Flags.IsBitSet(0)) { writer.Write(LastSaleDate.Value); }
        if (Flags.IsBitSet(0)) { writer.Write(LastSalePrice.Value); }
        if (Flags.IsBitSet(2)) { writer.Write(FloorPrice.Value); }
        if (Flags.IsBitSet(3)) { writer.Write(AveragePrice.Value); }
        if (Flags.IsBitSet(4)) { writer.Write(ListedCount.Value); }
        if (Flags.IsBitSet(5)) { writer.Write(FragmentListedCount.Value); }
        if (Flags.IsBitSet(5)) { writer.Write(FragmentListedUrl); }
    }

    public void Deserialize(ref ReadOnlyMemory<byte> buffer)
    {
        Flags = buffer.ReadInt32();
        if (Flags.IsBitSet(1)) { LastSaleOnFragment = true; }
        if (Flags.IsBitSet(6)) { ValueIsAverage = true; }
        Currency = buffer.ReadString();
        Value = buffer.ReadInt64();
        InitialSaleDate = buffer.ReadInt32();
        InitialSaleStars = buffer.ReadInt64();
        InitialSalePrice = buffer.ReadInt64();
        if (Flags.IsBitSet(0)) { LastSaleDate = buffer.ReadInt32(); }
        if (Flags.IsBitSet(0)) { LastSalePrice = buffer.ReadInt64(); }
        if (Flags.IsBitSet(2)) { FloorPrice = buffer.ReadInt64(); }
        if (Flags.IsBitSet(3)) { AveragePrice = buffer.ReadInt64(); }
        if (Flags.IsBitSet(4)) { ListedCount = buffer.ReadInt32(); }
        if (Flags.IsBitSet(5)) { FragmentListedCount = buffer.ReadInt32(); }
        if (Flags.IsBitSet(5)) { FragmentListedUrl = buffer.ReadString(); }
    }
}
