// <auto-generated />

namespace MyTelegram.Schema;

/// <summary>
/// Represents a stickerset (stickerpack)
/// <para>See <a href="https://corefork.telegram.org/constructor/stickerSet" /></para>
/// </summary>
[TlObject(0x2dd14edc)]
public sealed partial class TStickerSet : IStickerSet
{
    public uint ConstructorId => 0x2dd14edc;
    /// <summary>
    /// Flags, see <a href="https://corefork.telegram.org/mtproto/TL-combinators#conditional-fields">TL conditional fields</a>
    /// </summary>
    public int Flags { get; set; }

    /// <summary>
    /// Whether this stickerset was archived (due to too many saved stickers in the current account)
    /// </summary>
    public bool Archived { get; set; }

    /// <summary>
    /// Is this stickerset official
    /// </summary>
    public bool Official { get; set; }

    /// <summary>
    /// Is this a mask stickerset
    /// </summary>
    public bool Masks { get; set; }

    /// <summary>
    /// This is a custom emoji stickerset
    /// </summary>
    public bool Emojis { get; set; }

    /// <summary>
    /// Whether the color of this TGS custom emoji stickerset should be changed to the text color when used in messages, the accent color if used as emoji status, white on chat photos, or another appropriate color based on context.
    /// </summary>
    public bool TextColor { get; set; }

    /// <summary>
    /// If set, this custom emoji stickerset can be used in <a href="https://corefork.telegram.org/api/emoji-status">channel/supergroup emoji statuses</a>.
    /// </summary>
    public bool ChannelEmojiStatus { get; set; }

    /// <summary>
    /// Whether we created this stickerset
    /// </summary>
    public bool Creator { get; set; }

    /// <summary>
    /// When was this stickerset installed
    /// </summary>
    public int? InstalledDate { get; set; }

    /// <summary>
    /// ID of the stickerset
    /// </summary>
    public long Id { get; set; }

    /// <summary>
    /// Access hash of stickerset
    /// </summary>
    public long AccessHash { get; set; }

    /// <summary>
    /// Title of stickerset
    /// </summary>
    public string Title { get; set; }

    /// <summary>
    /// Short name of stickerset, used when sharing stickerset using <a href="https://corefork.telegram.org/api/links#stickerset-links">stickerset deep links</a>.
    /// </summary>
    public string ShortName { get; set; }

    /// <summary>
    /// Stickerset thumbnail
    /// See <a href="https://corefork.telegram.org/type/PhotoSize" />
    /// </summary>
    public TVector<MyTelegram.Schema.IPhotoSize>? Thumbs { get; set; }

    /// <summary>
    /// DC ID of thumbnail
    /// </summary>
    public int? ThumbDcId { get; set; }

    /// <summary>
    /// Thumbnail version
    /// </summary>
    public int? ThumbVersion { get; set; }

    /// <summary>
    /// Document ID of custom emoji thumbnail, fetch the document using <a href="https://corefork.telegram.org/method/messages.getCustomEmojiDocuments">messages.getCustomEmojiDocuments</a>
    /// </summary>
    public long? ThumbDocumentId { get; set; }

    /// <summary>
    /// Number of stickers in pack
    /// </summary>
    public int Count { get; set; }

    /// <summary>
    /// Hash
    /// </summary>
    public int Hash { get; set; }

    public void ComputeFlag()
    {
        if (Archived) { Flags = Flags.SetBit(1); }
        if (Official) { Flags = Flags.SetBit(2); }
        if (Masks) { Flags = Flags.SetBit(3); }
        if (Emojis) { Flags = Flags.SetBit(7); }
        if (TextColor) { Flags = Flags.SetBit(9); }
        if (ChannelEmojiStatus) { Flags = Flags.SetBit(10); }
        if (Creator) { Flags = Flags.SetBit(11); }
        if (/*InstalledDate != 0 && */InstalledDate.HasValue) { Flags = Flags.SetBit(0); }
        if (Thumbs?.Count > 0) { Flags = Flags.SetBit(4); }
        if (/*ThumbDcId != 0 && */ThumbDcId.HasValue) { Flags = Flags.SetBit(4); }
        if (/*ThumbVersion != 0 && */ThumbVersion.HasValue) { Flags = Flags.SetBit(4); }
        if (/*ThumbDocumentId != 0 &&*/ ThumbDocumentId.HasValue) { Flags = Flags.SetBit(8); }
    }

    public void Serialize(IBufferWriter<byte> writer)
    {
        ComputeFlag();
        writer.Write(ConstructorId);
        writer.Write(Flags);
        if (Flags.IsBitSet(0)) { writer.Write(InstalledDate.Value); }
        writer.Write(Id);
        writer.Write(AccessHash);
        writer.Write(Title);
        writer.Write(ShortName);
        if (Flags.IsBitSet(4)) { writer.Write(Thumbs); }
        if (Flags.IsBitSet(4)) { writer.Write(ThumbDcId.Value); }
        if (Flags.IsBitSet(4)) { writer.Write(ThumbVersion.Value); }
        if (Flags.IsBitSet(8)) { writer.Write(ThumbDocumentId.Value); }
        writer.Write(Count);
        writer.Write(Hash);
    }

    public void Deserialize(ref ReadOnlyMemory<byte> buffer)
    {
        Flags = buffer.ReadInt32();
        if (Flags.IsBitSet(1)) { Archived = true; }
        if (Flags.IsBitSet(2)) { Official = true; }
        if (Flags.IsBitSet(3)) { Masks = true; }
        if (Flags.IsBitSet(7)) { Emojis = true; }
        if (Flags.IsBitSet(9)) { TextColor = true; }
        if (Flags.IsBitSet(10)) { ChannelEmojiStatus = true; }
        if (Flags.IsBitSet(11)) { Creator = true; }
        if (Flags.IsBitSet(0)) { InstalledDate = buffer.ReadInt32(); }
        Id = buffer.ReadInt64();
        AccessHash = buffer.ReadInt64();
        Title = buffer.ReadString();
        ShortName = buffer.ReadString();
        if (Flags.IsBitSet(4)) { Thumbs = buffer.Read<TVector<MyTelegram.Schema.IPhotoSize>>(); }
        if (Flags.IsBitSet(4)) { ThumbDcId = buffer.ReadInt32(); }
        if (Flags.IsBitSet(4)) { ThumbVersion = buffer.ReadInt32(); }
        if (Flags.IsBitSet(8)) { ThumbDocumentId = buffer.ReadInt64(); }
        Count = buffer.ReadInt32();
        Hash = buffer.ReadInt32();
    }
}
